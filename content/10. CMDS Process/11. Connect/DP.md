---
CMDS: Algorithm
관련 문서:
  - "[[Algorithm Concepts]]"
tags:
  - "#DP"
category: content
---
# DP

<center><i><b>D</b>ynamic <b>P</b>rogramming</i></center>

- DP의 조건
	- 사이클이 없는 방향 그래프
	- DAG - 메모이제이션 가능
- [[LCS]]
- [[Knapsack]]
- [[LIS]]

## 재귀 호출과 메모이제이션
#### 피보나치 수열
- 이전 두 수의 합을 다음 항으로 하는 수열
- $f(n) = f(n-1) + f(n-2)$  (n>=2)
- 재귀로 구현할 경우 중복 호출이 발생하는 문제가 존재
	- 이를 해결하기 위해 메모이제이션 사용

>[!tips]
><center><b>메모이제이션</b></center>
>
>*이전에 계산한 값을 메모리에 저장하여 매번 다시 계산하지 않도록 하여 실행속도를 빠르게 하는 기술*
- 같은 input이 주어질 경우 같은 output이 보장되는 경우에만 사용 가능

#### 피보나치 수열 memoization
- memo 배열 할당 수 0으로 초기화
- memo\[0] = 0, memo\[1] = 1로 초기화
	- 추가 메모리 공간 필요
	- 실행 속도 저하, 혹은 오버플로우 발생 가능성 존재
#### 메모이제이션을 등산에 비유
- 산 중간에 앞으로 남은 거리를 알고 싶을 때 
- 정상에서 내려오는 사람이 중간에 표지판을 세우면 올라가는 사람이 정상까지 올라가지 않더라도 등산로 전체 길이를 알 수 있음
- 메모이제이션 기법이 이와 유사함
- 이미 1번의 계산을 마쳤다면, 다음에 해당 계산이 필요한 경우 저장된 배열에서 꺼내서 사용
```java
public class Fibonacci {
	static int[] memo;
	public static long fibo(int n) {
		if(memo[n] == -1) {
			memo[n] = fibo(n-1) + fibo(n-2);
		}
		return memo[n];
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		memo = new long[N+1];

		Arrays.fill(memo, -1);
		memo[0] = 0;
		memo[1] = 1;
		
		System.out.println(fibo(N));
	}
}
```

## 동적 계획법
1. 작은 부분 문제의 해 구하기
2. 보다 큰 부분 문제 해결
3. 최종 문제 해결

#### 동적 계획법 적용 요건
- ##### 중복 부분문제 구조
	- 큰 문제를 작은 문제로 나누고, **작은 문제의 해결을 통해 큰 문제를 해결** => 점화식 사용
	- 이전 계산되었던 내용을 다시 사용하기 위해 **동적 테이블** 사용
	- **테이블 참조**를 통해 중복 계산을 피함
- ##### 최적 부분문제 구조
	- **최적화의 원칙**을 만족해야 함
		- 어떤 문제의 해가 최적일 때 작은 문제의 해 역시 최적이어야 함

#### 분할 정복과 비교
- ##### 분할 정복
	- 연관 없는 부분 문제로 분할
	- 부분 문제를 재귀로 해결
	- 해를 결합
- ##### DP
	- 부분 문제들이 연관 있어야 함
	- 부분 문제를 한번만 계산하고 결과를 재사용

#### DP 적용 방법
##### 1. 문제에 대한 이해와 정의
- 최적해 문제인가? 경우의 수인가?
##### 2. 부분문제 식별
- 이 문제를 어떻게 쪼갤 것인가?
##### 3. 동적 테이블 정의
- 부분 문제에 대한 상태 정의
- 상태를 표현 가능한 자료구조 설계
	- 1차원, 2차원, ...
##### 4. 부분 문제들의 관계 파악 후 점화식 도출
- D\[i], D\[i-1], D\[i-2], ... 이게 어떤 관계가 있을까?
- 관계가 수립이 안되는 경우 파악
##### 5. 동적테이블 초기화 및 부분문제 해 계산
- 기저상황 상태 초기화
- 점화식을 이용한 테이블 채우기
##### 6. 해 도출
##### 7. (선택) 공간복잡도 최적화

#### DP 접근 방법
1. 하향식 접근으로 설계
2. 상태공간 트리 작성
	- 중복 호출 파악
3. 기저부터 상향식으로 뒤집어서 생각
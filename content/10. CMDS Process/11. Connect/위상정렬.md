---
CMDS: Algorithm
관련 문서:
  - "[[그래프]]"
tags:
  - "#Algorithm"
category: content
---
## 위상 정렬

>[!tips]
>싸이클이 없는 방향 그래프에서 노드 순서를 찾는 알고리즘
>>정렬 결과가 꼭 1개는 아닐 수 있음
- 순서가 정해져 있는 작업들을 차례대로 수행할 때 순서를 결정해 주는 알고리즘

### 개요
위상 정렬은 **방향성이 있는 비순환 그래프(DAG: Directed Acyclic Graph)** 에서 노드들의 선형 순서를 찾는 알고리즘입니다. 이 정렬은 그래프의 모든 간선을 고려하여 각 노드가 올바른 순서에 배치되도록 합니다. 위상 정렬의 대표적인 활용 사례는 **작업의 순서 결정**, **프로그래밍 빌드 시스템**, **패키지 의존성 관리** 등이 있습니다.

### 주요 특징
- **비순환성 (Acyclic)**: 그래프에 사이클이 없어야 위상 정렬이 가능합니다. 사이클이 존재하면 정렬이 불가능합니다.
- **비유일성 (Non-unique)**: 위상 정렬의 결과는 그래프에 따라 여러 가지가 존재할 수 있습니다.
- **방향성 (Directed)**: 간선에 방향이 있어야 합니다.

### 위상 정렬의 알고리즘

위상 정렬을 구현하는 알고리즘에는 주로 **Kahn의 알고리즘**과 **깊이 우선 탐색(DFS)** 을 이용한 방법이 있습니다. 여기서는 Kahn의 알고리즘을 중심으로 설명하겠습니다.

#### Kahn의 알고리즘

1. **진입 차수 계산 (Compute In-degree)**
   - 그래프의 모든 노드에 대해 진입 차수를 계산합니다.
   - 진입 차수는 다른 노드에서 해당 노드로 들어오는 간선의 수를 의미합니다.
   - 진입 차수가 0인 노드는 선행 작업이 필요 없는 작업입니다.

2. **진입 차수가 0인 노드 큐에 추가 (Initialize Queue)**
   - 진입 차수가 0인 모든 노드를 큐에 삽입합니다.
   - 이 노드들은 정렬 과정에서 가장 먼저 처리됩니다.

3. **정렬 진행 (Process Queue)**
   - 큐가 빌 때까지 다음을 반복합니다:
     - 큐에서 노드를 하나 꺼내 정렬된 리스트에 추가합니다.
     - 해당 노드가 가리키는 모든 인접 노드의 진입 차수를 1씩 감소시킵니다.
     - 진입 차수가 0이 된 인접 노드를 큐에 추가합니다.

4. **결과 확인 (Check for Cycles)**
   - 모든 노드가 정렬된 리스트에 포함되었다면 위상 정렬이 성공한 것입니다.
   - 포함되지 않았다면 그래프에 사이클이 존재하여 위상 정렬이 불가능합니다.

#### 예제

다음과 같은 그래프를 고려해보겠습니다:

```
A → C
B → C
C → D
D → E
```

1. **진입 차수 계산**
   - A: 0
   - B: 0
   - C: 2 (A, B)
   - D: 1 (C)
   - E: 1 (D)

2. **초기 큐**
   - A, B

1. **정렬 과정**
   - 큐에서 A를 꺼내 정렬: \[A]
      - C의 진입 차수를 1로 감소 (C: 1)
   - 큐에서 B를 꺼내 정렬: \[A, B]
     - C의 진입 차수를 0으로 감소 (C: 0), 큐에 C 추가
   - 큐에서 C를 꺼내 정렬: \[A, B, C]
     - D의 진입 차수를 0으로 감소 (D: 0), 큐에 D 추가
   - 큐에서 D를 꺼내 정렬: \[A, B, C, D]
     - E의 진입 차수를 0으로 감소 (E: 0), 큐에 E 추가
   - 큐에서 E를 꺼내 정렬: \[A, B, C, D, E]

4. **결과 확인**
   - 모든 노드가 정렬되었으므로 위상 정렬 성공
   - 가능한 정렬 결과 중 하나: A, B, C, D, E

### 시간 복잡도
- **O(V + E)**: 노드(V)와 간선(E)의 수에 비례하여 수행됩니다. 각 노드와 간선을 한 번씩 처리하기 때문입니다.

### 위상 정렬의 응용

1. **작업 스케줄링 (Task Scheduling)**
   - 선후 관계가 있는 작업들을 효율적으로 배치할 때 사용됩니다.

2. **컴파일러 (Compiler)**
   - 소스 코드의 의존성 분석 및 컴파일 순서를 결정합니다.

3. **패키지 관리 (Package Management)**
   - 소프트웨어 패키지의 의존성을 해결하고 설치 순서를 결정합니다.

4. **데이터 처리 파이프라인 (Data Processing Pipelines)**
   - 데이터 처리 단계 간의 의존성을 관리하고 실행 순서를 결정합니다.

### 사이클 감지

위상 정렬을 시도할 때 사이클이 존재하면 정렬이 불가능합니다. 따라서 알고리즘 중간에 모든 노드를 정렬 리스트에 포함시킬 수 없는 경우, 그래프에 사이클이 있다고 판단할 수 있습니다. 이 경우 추가적인 처리가 필요합니다.

### 요약

위상 정렬은 DAG에서 노드의 선형 순서를 찾는 효율적인 방법으로, 여러 분야에서 그 응용 가능성이 높습니다. Kahn의 알고리즘은 직관적이고 구현이 용이하여 널리 사용되며, 사이클 감지 기능도 내장하고 있어 그래프의 유효성을 검증하는 데에도 유용합니다.

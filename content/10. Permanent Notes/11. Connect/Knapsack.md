---
CMDS: "[[103 Algorithm]]"
creation date: 2025-04-07 09:16
modification date: 2025-04-07 09:16:26
type:
  - note
tags:
  - "#DP"
  - "#Knapsack"
관련 문서:
  - "[[DP]]"
category: content
---
# Knapsack

<center><i>n개의 물건과 각 물건 i의 무게 w와 v가 주어지고, 배낭의 용량이 W일때<br>
배낭에 담을 수 있는 물건의 취대 가치를 찾는 문제</i></center>
## 0-1 knapsack
- 배낭에 물건을 통째로 담아야 함
- 물건을 쪼갤 수 없는 경우

#### 부분문제
- 담을 수 없는 경우 -> 담지 않음
- 담을 수 있는 경우 -> 물건을 담은 것과, 담지 않은 경우 중 최대값

### 정의
0-1 Knapsack 문제는 주어진 무게 제한 내에서 물건의 가치를 최대화하는 조합을 찾는 최적화 문제입니다. 각 물건은 **전체를 담거나 담지 않거나** 선택할 수 있으며, 물건을 분할할 수 없습니다.

### 특징
- **배낭의 용량 제한**: 배낭에 담을 수 있는 최대 무게가 정해져 있습니다.
- **물건의 무게와 가치**: 각 물건은 무게와 가치가 정해져 있습니다.
- **선택의 제약**: 각 물건은 **0개 또는 1개**만 담을 수 있습니다 (즉, 분할할 수 없음).

### 문제 설명
- **입력**:
	- $W$- 배낭의 용량
	- $(v_i, w_i)$ = 가치, 무게
	- $K[i, w]$ = 물건 1~i까지 용량이 w일때 최대 가치

- **목표**:
  - 배낭에 담을 물건의 조합을 선택하여, 배낭에 담긴 물건들의 총 무게가 \( W \)를 초과하지 않으면서, 총 가치를 최대화하는 것.

### 예시

배낭의 최대 무게가 50kg이고, 다음과 같은 4개의 물건이 있다고 가정합시다:

| 물건  | 무게 \( w_i \) | 가치 \( v_i \) |
| --- | ------------ | ------------ |
| 1   | 10kg         | 60           |
| 2   | 20kg         | 100          |
| 3   | 30kg         | 120          |
| 4   | 20kg         | 75           |

이 경우, 배낭에 담을 수 있는 최대 가치는 **220**으로, 물건 **2와 3**을 선택하는 조합입니다. (20kg + 30kg = 50kg ≤ 50kg, 100 + 120 = 220)
### 동적 프로그래밍을 이용한 해결 방법

0-1 배낭 문제는 동적 프로그래밍(Dynamic Programming)을 사용하여 효율적으로 해결할 수 있습니다. 기본 아이디어는 다음과 같습니다:

1. **테이블 정의**: \( dp\[i]\[w] \)를 첫 \( i \)개의 물건을 고려했을 때, 무게 \( w \) 이하로 담았을 때의 최대 가치로 정의합니다.
2. **점화식**:
$$
dp[i][w] = \begin{cases}
0 & \text{if } i = 0 \text{ or } w = 0 \\
dp[i-1][w] & \text{if } w_i > w \\
\max(v_i + dp[i-1][w - w_i],\ dp[i-1][w]) & \text{if } w_i \leq w
\end{cases}
$$
- 만약 현재 물건의 무게 \( $w_i$ \)가 현재 고려하는 무게 \( $w$ \)보다 크다면, 해당 물건을 선택할 수 없으므로 이전 물건들만 고려한 값 \( $dp[i-1][w]$ \)이 최대 가치가 됩니다.
- 그렇지 않다면, 물건을 선택했을 때의 가치 \( $v_i + dp[i-1][w - w_i]$ \)와 선택하지 않았을 때의 가치 \( $dp[i-1][w]$ \) 중 더 큰 값을 선택합니다.
- 2차원 테이블 작성 시 테이블의 값은 해당 무게에서 가능한 최대 가치를 의미한다.

|     | 0kg | 10kg | 20kg | 30kg | 40kg | 50kg |
| --- | --- | ---- | ---- | ---- | ---- | ---- |
| 0   | 0   | 0    | 0    | 0    | 0    | 0    |
| 60  | 0   | 60   | 60   | 60   | 60   | 60   |
| 100 | 0   | 60   | 100  | 160  | 160  | 160  |
| 120 | 0   | 60   | 100  | 160  | 180  | 220  |
| 75  | 0   | 60   | 100  | 160  | 180  | 235  |


---

### 동적 프로그래밍 알고리즘 구현 예시 (java)

동적 프로그래밍 접근법을 기반으로 한 java 코드

```java
public class knapsack {
	static int[][] dp;
	static int N;
	static int K;
	static int[] weight;
	static int[] value;
	public static void main(String[] args) {
		knap();
		System.out.println(dp[N][K]);
	}

	static void knap() {
		dp = new int[N+1][K+1];
		for(int i=1; i<N+1; i++) {
			for(int j=1; j<K+1; j++) {
				if(weight[i] < j) {
					dp[i][j] = dp[i-1][j];
				} else {
					dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i]);
				}
			}
		}
	}
}
```

**설명:**
- `weights`와 `values`는 각각 물건의 무게와 가치를 나타내는 리스트입니다.
- `W`는 배낭의 최대 무게입니다.
- 이 함수는 배낭에 담을 수 있는 최대 가치를 반환합니다.
- 예시에서는 최대 가치인 220이 출력됩니다.

### 시간 복잡도
- **동적 프로그래밍 접근법**: \( O(nW) \)
  - \( n \)은 물건의 수, \( W \)는 배낭의 무게 제한입니다.

### 활용 사례
- **자원 배분 문제**
- **투자 포트폴리오 최적화**
- **프로젝트 선택 시 자본 제한**



## Fractional Knapsack
- 물건을 부분적으로 담는 것이 허용
- 물건을 쪼갤 수 있을 경우